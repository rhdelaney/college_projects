(define (main)
  (setPort (open (getElement ScamArgs 1) 'read))
  (define f (readExpr))
  (println (infix->postfix f))
  ;(println (infix->postfix '(2 + 3 * x ^ 5 + a)))
  ;Basically it thinks 'a' is a symbol/operation which I guess technically it kinda is in scheme
  ; so basically add a proper conditional check -> (if (operation in) else( treat like integer)) 
)
(define (flatten x)
  (cond ((null? x) '())
        ((pair? x) (append (flatten (car x)) (flatten (cdr x))))
        (else (list x)))
)
(define (peek S)
    (if (null? S)
        '()
        (car S)
    )
)
; Returns the stack without the top element
(define (pop S)
    (if (null? S)
        '()
        (cdr S)
    )
)
; Adds an element to the front of a S
(define (push S el)
    (if (null? S)
        (list el)
        (append (list el) S)
    )
)
; Returns true if op1 has higher precedence than op2
(define (checkPrec op1 op2)
    (define prList '(^ / * - +))
    (define (iter prList)
        (cond
            ((== (car prList) op1) #t)
            ((== (car prList) op2) #f)
            (else (iter (cdr prList)))
        )
    )
    (iter prList)
)
(define (checkSym o)
    (cond
        ((== o '^) #t)
        ((== o '/) #t)
        ((== o '*) #t)
        ((== o '-) #t)
        ((== o '+) #t)
        (else #f)
    )
)
; Adds all of the given list to a stack (basically reverses it)
(define (pushAll L)
    (println L)
    (define (iter LL S)
        (if (null? LL)
            S
            (iter (cdr LL) (push S (car LL)))
        )
    )
    (iter L '())
)
; Makes an expression from the element and the top 2 items of the stack
(define (makeExpr S el)
    ;(println S " : " el)
    ;(println (length S) " : " el) 
    ;(if(= (length S) 1)
        ;S
        (append (list (list (car S) (cadr S) el)) (cddr S))
    ;)
    ;(append (list (list (car S) (cadr S) el)) (cddr S))
)
; Empties the ops stack onto the output stack and returns the output
(define (emptyStack output ops)
    ;(println output " : " ops)
    (if (null? ops)
        output
        (if (>= (length ops) 2)
            (emptyStack (makeExpr output (car ops)) (cdr ops))
            (emptyStack (makeExpr output (car ops)) nil)
        )
    )
)

(define (infix->postfix Expr)
    (define (iter in out ops)
        ;(println in " : " out " : " ops)
        (if (null? in)
            ;(car 
            (emptyStack out ops)
            ;)
            (cond
                ((integer? (car in))
                    (iter (cdr in) (push out (car in)) ops)
                )
                ((symbol? (car in))
                        (if (null? ops)
                            (iter (cdr in) out (push ops (car in)))
                            (if (checkPrec (car in) (car ops))
                                (iter (cdr in) out (push ops (car in)))
                                (iter in (makeExpr out (car ops)) (cdr ops))
                            )
                        )
                )
                ;(else (iter (cdr in) (push out (car in)) ops)
                ;)
            )
        )
    )
    (flatten (iter (pushAll Expr) nil nil) )
)